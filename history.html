

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>History &mdash; Soylent Recipes 0.0.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Soylent Recipes 0.0.0 documentation" href="index.html"/>
        <link rel="prev" title="Ideas" href="ideas.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Soylent Recipes
          

          
          </a>

          
            
            
              <div class="version">
                0.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="user_guide.html">User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="ideas.html">Ideas</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">History</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#c-version">C++ version</a></li>
<li class="toctree-l2"><a class="reference internal" href="#python-version">Python version</a></li>
<li class="toctree-l2"><a class="reference internal" href="#brute-force-search">Brute force search</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cluster-walk-search">Cluster walk search</a></li>
<li class="toctree-l2"><a class="reference internal" href="#clustering-distance-metric">Clustering: distance metric</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pseudo-targets">Pseudo targets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nutrient-values-normalization">Nutrient values normalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#greedy-search">Greedy search</a></li>
<li class="toctree-l2"><a class="reference internal" href="#random-search">Random search</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recipe-solvers">Recipe solvers</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Soylent Recipes</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>History</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/history.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="history">
<h1>History<a class="headerlink" href="#history" title="Permalink to this headline">¶</a></h1>
<p>Summary of the project&#8217;s history. This is not intended to be a changelog.</p>
<p>Some terminology:</p>
<ul class="simple">
<li>food: a vector of nutrient values, named after the food it represents</li>
<li>nutrition target: the daily amount of nutrients to achieve. There are 2
different models of this through the course of the project&#8217;s history.</li>
<li>recipe: a combination of foods along with amounts of each food to use</li>
<li>search/mining: combining foods in a way that (hopefully) yields good recipes</li>
<li>solving: finding the amounts to use of each food, given a list of foods to
use</li>
</ul>
<div class="section" id="c-version">
<h2>C++ version<a class="headerlink" href="#c-version" title="Permalink to this headline">¶</a></h2>
<p>About 3 years ago, I made the first attempt to find soylent recipes. It was
written in C++. It took about 12ms to solve a recipe (in retrospect, this is
very slow). I tried searching by a k-means and a hierarchical clustering (with
alglib). Finally, I tried a genetic algorithm (with the BEAGLE library).
Neither had much success, but this was due to a bug in the recipe scoring
algorithm; e.g. water was considered enough to &#8216;eat&#8217; to meet the daily
nutrition target; i.e. all experiments had to be redone.</p>
<p>Nowadays, I know not to rely on output coming from software that has not been
thoroughly tested. More important modules of the software, get more thorough
testing than other modules (e.g. a bug in food sorting in outputted recipes
going undetected, is not a big problem).</p>
</div>
<div class="section" id="python-version">
<h2>Python version<a class="headerlink" href="#python-version" title="Permalink to this headline">¶</a></h2>
<p>Instead of continuing, I started over in Python. While you could achieve better
performance in C++, the increase in development time is generally not worth it.</p>
<p>I started by constructing a nutrition target based on the DRI. This nutrition
target consisted of 3 optional parts:</p>
<ul class="simple">
<li>extrema/bounds: min and max of each nutrient. Binary: in range / out of
range.</li>
<li>target: achieve as closely as possible</li>
<li>minimize: equivalent to target=0, except for it being weighted</li>
</ul>
<p>Eventually this nutrition target was simplified to just having extrema. Target
and minimize were hardly used and can be sufficiently approximated using
extrema.</p>
<p>Then, I parsed and cleaned the USDA foods data with respect to the nutrition
target; filling in some missing nutrition values with 0 and dropping foods with
too many missing data entirely. The recipe solver does not handle missing data,
so we must fill missing values or drop far too many foods. This left about 6400
of 8000 foods.</p>
<p>For the first recipe solver, I used a linear program (cvxopt.solvers.lp). Despite
testing, I overlooked a misunderstanding of Ax=b, expecting it to solve a least
squares. It will be worthwhile to read a book on optimization algorithms next
time I need one.</p>
</div>
<div class="section" id="brute-force-search">
<h2>Brute force search<a class="headerlink" href="#brute-force-search" title="Permalink to this headline">¶</a></h2>
<p>As a baseline, I implemented a trivial brute force search, which tries the
cartesian product: <cite>foods**max_foods</cite> (with <cite>max_foods&lt;10</cite>), a combinatorial
explosion. In retrospect, randomly selecting foods would have made a better
baseline. In the future, I will use such an unbiased probabilistic algorithm as
baseline.</p>
</div>
<div class="section" id="cluster-walk-search">
<h2>Cluster walk search<a class="headerlink" href="#cluster-walk-search" title="Permalink to this headline">¶</a></h2>
<p>With brute force not yielding any result (and not knowing that the solver had a
bug), I switched to a more informed search algorithm. This is later called
cluster_walk and eventually removed in favor of simple random search. It
combines foods by crawling a hierarchical clustering top-down. Leaf nodes are
foods. In a recipe, each cluster node is replaced by the food closest to its
center.  The clustering is generated with scikit-learn; it is agglomerative,
the distance metric is euclidean distance and the linkage is complete.</p>
<p>Complete linkage was chosen to have a max distance between foods per cluster.
The search algorithm treats this as the opposite of the level of detail. The
idea is to combine at low levels of detail first, to weed out less promising
combinations, and then increase detail by splitting clusters into their
children.</p>
<p>At each cluster split, when exceeding <cite>max_foods</cite>, one of the clusters of the
recipe is dropped, but each recipe that is (only marginally) better than the
parent recipe (i.e.  before splitting a cluster) is added to a top k recipes
structure (using the heapq library for efficiency). When <cite>k</cite> is exceeded, the
top k pops, in its final version, the lowest scoring recipe. The cluster walk,
at each iteration, pops the least detailed recipe from the top k, splits it and
adds it splits back to the top k.</p>
<p>Note that cluster walk requires a solver which provides scores on partial
solutions (i.e. when nutrition target is not fully satisfied).</p>
<p>While cluster walk very quickly reached a good solution, it only gave a single
solution despite having a top k as they were only k variations of 1 recipe.
This is due to popping the lowest scoring recipe and pushing <cite>max_foods</cite>
variations of the same recipe at each split of a cluster. One possible way
around this is to also take into account similarity to other recipes when
popping when exceeding <cite>k</cite>, such that if 2 recipes are sufficiently similar, pop
the lowest scoring of those 2 recipes.</p>
<p>The final clustering (with normalized foods and RED as distance metric) is
available as a <a class="reference external" href="file/clustering_depth37.newick">newick formatted file</a> and as a
<a class="reference external" href="file/clustering_depth37_rectangular.pdf">rectangular dendrogram in pdf</a> (the latter may take a few
minutes to load).</p>
<p>Not that the USDA data appears to include a curated clustering (perhaps not
hierarchical), that I could have used to quickly have a first clustering,
before trying to make one more suited for the task at hand (i.e. based on
nutrient values, ignoring scale).</p>
</div>
<div class="section" id="clustering-distance-metric">
<h2>Clustering: distance metric<a class="headerlink" href="#clustering-distance-metric" title="Permalink to this headline">¶</a></h2>
<p>Euclidean distance is chosen over Manhattan distance as we care more about
larger individual differences than smaller ones. E.g. we consider <cite>target -
actual = [0.1, 0.9]</cite> as far worse than a difference vector of <cite>[0.5, 0.5]</cite>.
Manhattan distance would yield the same distance on each of the former
difference vectors.</p>
<p>The ideal distance metric assigns low distance to foods which behave similarly
in a recipe. Thus differences in scale do not matter as when <cite>food1=z*food2</cite>
(<cite>z&gt;0</cite>) we can simply take <cite>z</cite> amount of <cite>food2</cite> to match <cite>food1</cite> and thus the
distance between these 2 foods should be 0.</p>
<p>To incorporate this, the clustering distance metric was changed to relative
Euclidean distance (RED), which ignores scale.</p>
<p>Later, clustering was entirely removed as the only search algorithm left
(random), does not use it.</p>
</div>
<div class="section" id="pseudo-targets">
<h2>Pseudo targets<a class="headerlink" href="#pseudo-targets" title="Permalink to this headline">¶</a></h2>
<p>At the time, a least squares solver was in use which minimized <cite>foods * amounts
= nutrition_target</cite>. I.e. it did not support extrema and required everything to
be converted to a single target vector called the pseudo-targets.</p>
<p>This conversion went as follows for extrema:</p>
<ul class="simple">
<li><cite>min+max/2</cite>, if it has a min and a max</li>
<li><cite>max/2</cite>, if it has only a max.</li>
<li><cite>1.1*min</cite>, if it has only a min.</li>
</ul>
<p>The min-only pseudo-target exceeds the min a bit so that least squares does
not undershoot the min as easily, as it does not care whether the difference is
negative or positive.</p>
<p>The max-only psuedo-target does the same thing however the pseudo-target
is set to <cite>0.5 * max</cite> instead of <cite>0.9 * max</cite>, the latter being admittedly
somewhat arbitrary.</p>
<p>Later, as solvers supported proper extrema, pseudo targets were removed;
greatly simplifying things.</p>
</div>
<div class="section" id="nutrient-values-normalization">
<h2>Nutrient values normalization<a class="headerlink" href="#nutrient-values-normalization" title="Permalink to this headline">¶</a></h2>
<p>The clustering and recipe scoring (for solvers that provide a score) was
further improved by normalizing nutrient values to their nutrition target. For
example when <cite>nutrient1</cite> and <cite>nutrient2</cite> have a target of 1 and 10
respectively, a difference of 1 in <cite>nutrient1</cite> should be equivalent to a
difference of <cite>10</cite> in <cite>nutrient2</cite>. To get Euclidean distance (used in both
clustering and recipe scoring) to treat these as equal, we divide nutrient
values by their target (or their pseudo target).</p>
<p>Later, clustering and recipe scoring were removed, and thus nutrient
normalization was removed as well.</p>
</div>
<div class="section" id="greedy-search">
<h2>Greedy search<a class="headerlink" href="#greedy-search" title="Permalink to this headline">¶</a></h2>
<p>Greedy search starts from a random sample of foods of size <cite>max_foods</cite>. It then
makes a single pass over the foods. At iteration i, it replaces the i-th food
with the food that yields the highest score combined with the other foods in
the recipe. This requires a solver that returns a score (on partial solutions).</p>
<p>Greedy search was later removed as it is outperformed by random search.
Only comparing to foods in the clustering, cut to a certain <cite>max_distance</cite>
(or equivalently, level of detail), might outperform random search.</p>
</div>
<div class="section" id="random-search">
<h2>Random search<a class="headerlink" href="#random-search" title="Permalink to this headline">¶</a></h2>
<p>Take a random sample of foods of size <cite>max_foods</cite>, drop unused foods. Do this
until <cite>k</cite> solved recipes have been found.</p>
</div>
<div class="section" id="recipe-solvers">
<h2>Recipe solvers<a class="headerlink" href="#recipe-solvers" title="Permalink to this headline">¶</a></h2>
<p>Recipe solvers in the order we tried them.</p>
<p>With the old more complex nutrition target:</p>
<ul>
<li><p class="first">cvxopt.solvers.lp</p>
<p>Ax=b used for targets. However instead of first satisfying <cite>extrema</cite>, then
least squaring the <cite>targets</cite> and finally minimizing <cite>minimize</cite>, this first
least squared the <cite>targets</cite> and then tried to satisfy <cite>extrema</cite>. This
resulted in far more infeasible status results than necessary.</p>
</li>
<li><p class="first">numpy.linalg.lstsq</p>
<p>Least squares of <cite>foods * amounts = pseudo_targets</cite>. However, <cite>amounts</cite> can be
negative! Returns the negative of its residue as score.</p>
<p>Pseudo target derivation contained a bug at this point.</p>
</li>
<li><p class="first">scipy.optimize.nnls</p>
<p>Like, numpy.linalg.lstsq, except nnls ensures <cite>amounts&gt;=0</cite>.
Solves 3767 recipes / s</p>
<p>Some time after, pseudo targets were fixed and the nutrition target was
simplified to just extrema.</p>
</li>
</ul>
<p>With the simple nutrition target (just extrema):</p>
<ul>
<li><p class="first">sympy: solve symbolically</p>
<ul>
<li><p class="first">Matrix.gauss_jordan_solve, LUsolve, LUdecomposition, linsolve (a wrapper
around Matrix.gauss_jordan_solve).</p>
<p>#math (freenode) suggested to treat the extrema as a system of inequalities
to solve symbolically with Gaussian elimination.</p>
<p>Rewriting the problem properly as described in the scipy.optimize.nnls
solution below would work, but solving the problem numerically is faster
than solving it symbolically. There is no reason to solve it symbolically.</p>
</li>
<li><p class="first">reduce_inequalities</p>
<p>Only supports univariate inequalities.</p>
</li>
</ul>
</li>
<li><p class="first">scipy.optimize.nnls</p>
<p>We realized how to rewrite the real problem as a least squares problem, i.e.
it solves with extrema in mind and not some pseudo targets (the latter were
removed after this solver was implemented). This solves at a whopping rate of
about 1000 recipes / s (after optimizing with profiler). However, amounts are
floats, not integers, which may be hard to measure properly (e.g. weighing
1.02g can be tricky)</p>
<p>Before showing how to rewrite, consider these definitions:</p>
<ul class="simple">
<li><cite>x</cite> (above referred to as <cite>amounts</cite>): real vector &gt;=0, the amounts of each food, the unknown we want to
solve for.</li>
<li><cite>A</cite> (above referred to as <cite>foods</cite>): matrix, with A_ij = the amount of
nutrient_i in (1g of) food_j.</li>
<li><cite>m</cite>: vector&gt;=0, minima (nan replaced by 0) of the nutrition target. m_i
is the minimum of nutrient_i to ahve.</li>
<li><cite>M</cite>: maxima of the nutrition target. M&gt;m.</li>
</ul>
<p>and these notations:</p>
<ul class="simple">
<li><cite>[A;B]</cite>: stack matrices vertically, on top of each other</li>
<li><cite>[A,B]</cite>: stack matrices horizontally, next to each other</li>
</ul>
<p>We want to solve <cite>Ax&gt;=m and Ax&lt;=M</cite>.  A least squares problem is of the form
<cite>Ax=b</cite>.</p>
<p>First we combine the minima and maxima. Given that <cite>Ax&gt;=m iff -Ax&lt;=-m</cite>,
solving <cite>Ax&gt;=m and Ax&lt;=M</cite> is equivalent to solving <cite>[-A;A] x &lt;= [-m;M]</cite>.</p>
<p>For brevity, we introduce some variables:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">D</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">A</span><span class="p">;</span><span class="n">A</span><span class="p">]</span>
<span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">m</span><span class="p">;</span><span class="n">M</span><span class="p">]</span>
<span class="n">solve</span> <span class="n">Dx</span><span class="o">&lt;=</span><span class="n">b</span>
</pre></div>
</div>
<p>Finally, note that <cite>Dx&lt;=b</cite> iff <cite>Dx+z=b, z&gt;=0, z is a vector</cite>. Or as least
squares <cite>[D,I] [x;z] = b</cite>.</p>
<p>So our least squares problem is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="o">-</span><span class="n">A</span><span class="p">;</span><span class="n">A</span><span class="p">],</span> <span class="n">I</span><span class="p">]</span> <span class="p">[</span><span class="n">x</span><span class="p">;</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">m</span><span class="p">;</span><span class="n">M</span><span class="p">]</span>
</pre></div>
</div>
<p>The nutrition target is achieved iff the least squares residual is (close to)
0. In this case, the residual is the L2 norm of the vector of shortages to
the minima and excesses to the maxima.</p>
</li>
<li><p class="first">GLPK via ecyglpki wrapper:</p>
<p>Solve a mixed integer linear program with the GLPK library. Here, we can
directly supply the extrema to the algorithm without any rewriting. The
amounts are now constrained to integers. Linear program solvers are slower
than least squares, and mixed integer linear programs are generally even
slower, but in the measurement of the previous algorithm we could see we had
performance to spare. This solver solves at a rate of 298.7 recipes / s.</p>
<p>While GLPK&#8217;s KKT.PB check could provide us with a decent score when not able
to solve the recipe (i.e. nutrition target cannot be satisfied with the given
foods), the solver now only returns whether it solved or not instead of a
score. Score was used by greedy and cluster_walk search, which have been
removed at this point.</p>
<p>At the time of writing, the ecyglpki wrapper has a memory leak. I&#8217;ve <a class="reference external" href="https://github.com/equaeghe/ecyglpki/issues/9">reported
this bug</a> to ecyglpki.  Its last release is 2-3
years older than GLPK&#8217;s.</p>
<p>Note that we pick 0 as objective function. We do not have any price data on
our foods to optimize by. Also note that linear program libraries can differ
quite a bit; for example GLPK offers a <cite>KKT.*</cite> checks, whereas I did not
immediately find these in cvxopt.</p>
</li>
<li><p class="first">GLPK via python-glpk</p>
<p>Did not try this as it also appears to be out of date.</p>
</li>
<li><p class="first">GLPK via swiglpk wrapper:</p>
<p>Does not leak memory. Solves 229.6 recipes / s.</p>
<p>The profiler reveals that 40% of time is wasted on __setitem__ of
intArray/doubleArray of the swiglpk wrapper, which explains the performance
loss in switching to this wrapper. Perhaps this could be optimized away using
Cython, or rather swiglpk should offer an interface by which we can provide a
numpy array. Still, the current speed may still be acceptable.</p>
</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="ideas.html" class="btn btn-neutral" title="Ideas" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, your name.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>